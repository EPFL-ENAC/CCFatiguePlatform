# %% Environment setup
import pandas as pd
import numpy as np
from pathlib import Path
import glob
import os

# Constantes

DATA_DIRECTORY = '/Volumes/GoogleDrive/.shortcut-targets-by-id/306/FatigueDataPlatform files & data/Data Description/File directory example/'
DATE = '2021-04-20'
TEST_TYPE = 'FA'
TEST_NUMBER = '012'
LAB = "CCLAB"
RESEARCHER = 'Vahid'
DATA_STEP_IN = 'STD'
DATA_STEP_OUT = 'AGG'

### Importing all STD files
def read_df_list():
    """
    Arguments:
        Void

    Returns:
        dataframe containing as many lists as there are files in the respository

    Description:
        We specify a path to a repository containing all the tests in an experiment in their standard format
        Then a list is created for each test and stored in a dataframe with all other tests
    """


    filepath = os.path.join(DATA_DIRECTORY, LAB, RESEARCHER, TEST_TYPE, DATE, DATA_STEP_IN)


    os.chdir(filepath)

    # get data file names
    filenames = [i for i in glob.glob("*.csv")]
    df = [pd.read_csv(file, sep = ",", header=0, decimal='.') for file in filenames]
    print(filenames)
    return df


### Importing meta data from csv
def read_met():
    """
    Arguments:
        Void

    Returns:
        dataframe containing as many lists as there are files in the respository

    Description:
        We specify a path to a repository containing all the metadata in an experiment
        Then a list is created for each test and stored in a dataframe with all other tests
    """



    filepath = os.path.join(DATA_DIRECTORY, LAB, RESEARCHER, TEST_TYPE, DATE, DATA_STEP_IN)


    os.chdir(filepath)

    # get data file names
    filenames = [i for i in glob.glob("*.json")]
    print(filenames)
    meta_df = [pd.read_json(file, orient = 'index') for file in filenames]
    return meta_df


def write_agg(SNdf):

    filename = DATA_STEP_OUT+'_'+DATE+'_'+TEST_TYPE+'.csv'

    lab = "CCLab"
    researcher = 'Vahid'
    loading = 'Fatigue'

    output_path = os.path.join(DATA_DIRECTORY, LAB, RESEARCHER, TEST_TYPE, DATE, DATA_STEP_OUT)
    filepath = os.path.join(output_path,filename)

    SNdf.to_csv(path_or_buf=filepath, index=False)
    return


#print(df)

#setup df
def stress_n_cycles(df, meta_df):
    """
    Arguments:
        df: dataframe generated by the read_df_list() function
        meta_df: dataframe generated by the read_met() function

    Returns:
        agg_stress: list with the maximum stress for each test
        agg_n_cycles: list with the maximum number of cycles for each test

    Description:
        In this function, we first go across all the individual testings in order to find the maximum value of stress. We then fetch inside the metadata files
        the maximum number of cycles for all testings. The values are stored in the lists agg_stress and agg_n_cycles respectively
    """

    agg_stress = []
    agg_n_cycles = []

    #select max stress for all tests
    print(meta_df)
    for i in range(len(df)):
        stress = df[i].Machine_Load
        max_stress = max(stress)
        agg_stress.append(max_stress)

        n_cycles = meta_df[i].N_fail.value
        #max_n_cycles = max(n_cycles)
        agg_n_cycles.append(n_cycles)

    return agg_stress, agg_n_cycles


# %%

#print(stress)
#print(agg_stress)
#print(agg_n_cycles)

def calculate_stress_lev(meta_df, agg_stress, agg_n_cycles):
    """
    Arguments:
        meta_df: dataframe containing metadata of all testings
        agg_stress: list containing the maximum stress value for all testings
        agg_n_cycles: list containing the number of cycles to failure for all testings

    Returns:
        sortStress: Same values as agg_stress only arranged in descending order
        sortNCycles: Same values as agg_n_cycles arranged following the order of sortStress
        stressLev: Different levels of stress defined for the experiment, takes integer values
        R_ratio: list of stress ratio for all testings
        rel_level: list of reliability level for all testings

    Description:
        This function creates all the columns necessary for the aggregated format to be compatible with CCFatigue
        First step is to create the R ratio and reliability level columns
        Then we arrange the stress and cycles to failure columns and evaluate the stress level number by bunching up the tests that are supposed to
        have the same values for stress (may vary slightly due to geometric factors)
    """
    R_ratio = []
    rel_level = []
    for i in range(len(meta_df)):
        r_ratio = float(meta_df[i].R_Ratio.value)
        #rel_level = float(meta_df.Rel_level[0])
        r_level = float(meta_df[i].Rel_level.value)

        R_ratio.append(r_ratio)
        rel_level.append(r_level)


    percent = 0.05
    stressLev = []
    stressLevNo = 1

    # %% Stress level no
    sortStress, sortNCycles = zip(*sorted(zip(agg_stress, agg_n_cycles), reverse = True))
    maxValue = sortStress[0]
    for i in range (0,len(sortStress)):
        if sortStress[i] >= (1 - percent) * maxValue:
            stressLev.append(stressLevNo)
        else:
            maxValue = sortStress[i]
            stressLevNo = stressLevNo + 1
            stressLev.append(stressLevNo)
    return sortStress, sortNCycles, stressLev, R_ratio, rel_level





# %% Checkpoint
#print(stressLev)
#print(len(stressLev))
#print(len(sortStress))

# %% Constructing standard format for CCFatigue S-N curve


def create_agg(R_ratio, rel_level, stressLev, sortStress, sortNCycles):
    """
    Arguments:
        R_ratio: list with the values of R_ratio of the individual tests
        rel_level: list with the reliability levels of the individual tests
        stressLev: list of the stress level for the individual tests
        sortStress: list of maximum stress values for the individual tests
        sortNCycles: list of number of cycles to failure for the individual tests

    Returns:
        SNdf: data frame with 6 columns described by 'cols' and as many rows as there are tests

    Description:
        Takes the individual columns generated by calculate_stress_lev() and arranges them within a dataframe

    """

    cols = ['Stress_Ratio', 'Reliability_Level', 'Stress_Level_No', 'Stress_Parameter', 'Number_of_Cycles', 'Residual_Strength']
    SNdf = pd.DataFrame(columns = cols)

    SNdf.Stress_Ratio = R_ratio
    SNdf.Reliability_Level = rel_level
    SNdf.Stress_Level_No = stressLev
    SNdf.Stress_Parameter = sortStress
    SNdf.Number_of_Cycles = sortNCycles
    SNdf.Residual_Strength = sortStress
    print(SNdf)
    return SNdf




def main ():
    df = read_df_list()
    meta_df = read_met()
    agg_stress, agg_n_cycles = stress_n_cycles(df, meta_df)
    sortStress, sortNCycles, stressLev, R_ratio, rel_level = calculate_stress_lev(meta_df, agg_stress, agg_n_cycles)
    SNdf = create_agg(R_ratio, rel_level, stressLev, sortStress, sortNCycles)
    write_agg(SNdf)
    return

if __name__ == "__main__":
    main()

# %

# %%
